---
title: "Making maps of Ireland in R"
author: "Brendan O'Dowd"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction

This guide uses maps from my GitHub page produced using shapefiles from [OSi](https://data-osi.opendata.arcgis.com/) and [OSNI](https://www.spatialni.gov.uk/).
 
Two packages are used throughout, they are [tidyverse](https://tidyverse.tidyverse.org/) (actually a collection of packages) and [sf](https://r-spatial.github.io/sf/), which stands for simple features. To install any package run ```install.packages("package_name")```.

To start, we will need to load both of these packages.

```{r packages , message=FALSE}
library(tidyverse)
library(sf)
```

## Prerequisites

I would like for anyone to be able to begin making their own maps, but some familiarity with R is ideal. I think that in order to produce maps independently you should be able to use the following list of functions. The help function in R is very useful, you can find out about a function using ```?```, for example by entering ```?select```. 


- ```<-``` : the assignment operator in R (shortcut Alt -). E.g. ```x <- 5``` gives ```x``` the value 5. 
- ```select()``` : subsetting columns
- ```filter()``` : subsetting rows
- ```mutate()``` : create new variables
- ```group_by()``` : prepares a dataframe for operations to be carried out on groups of variables. Use ```ungroup()``` to remove grouping.
- ```%>%``` : this is the 'pipe' (shortcut Ctrl Shift m), it is a tool for pushing an object through a series of operations. It makes code easier to read and write. 
- ```c()``` : create a vector.
- Logical operators like ```==``` (equal to) ```!=``` (not equal to) ```&``` (and) ```|``` (or) ```%in%``` (in, I use this a lot to see if a string is in a vector of strings). 

Not an absolute necessity, but I find myself doing a lot of string matching when I'm making maps in R, and for that I use the ```str_detect()``` function. A very useful resource is the 'String manipulation with stringr cheatsheet', available on the [RStudio Cheatsheets page](https://www.rstudio.com/resources/cheatsheets/). 

## Importing maps

You **should** be able to import my maps directly from the web, using the following, which will create an object called ```lea_166```. 

```{r import_map , message=FALSE , results="hide"}
lea_166 <- st_read("https://raw.githubusercontent.com/brendanjodowd/maps/main/lea_166.geojson")

```

This is a map of the 166 Local Electoral Areas in Ireland, plus the outline for Northern Ireland, so there are 167 shapes in total, and a row for each of these, so 167 rows in ```lea_166```. In terms of structure, ```lea_166``` is an 'sf object', where sf stands for special features (check by running ```class(lea_166)```). This is a special type of dataframe where one of the columns is called ```geometry``` and contains the coordinates for the shapes corresponding to that row.  

I say **should** in the above because your organisation might not allow R to access the web in this way. If that's the case then you can navigate to the URL in the ```st_read()``` function, and save that page locally as a .geojson file. Then use the file location on your PC as the argument for ```st_read()```.


We will be able to use this map of 166 LEAs (plus Northern Ireland) to create other maps, such as county outlines and NUTS 3 region outlines.

There are 11 columns within ```lea_166```, they are:

- LE_ID : an id sometimes used by CSO
- LEA: The name of the LEA
- COUNTY: The county of the LEA
- AREA: area in square kilometres
- GUID: Globally Unique Identification code, another type of ID
- NUTS3 and NUTS2: NUTS (Nomenclature of Territorial Units for Statistics) regions are standard country subdivisions used for statistical purposes. 
- ADMIN_AREA: Ireland's 31 administrative areas. Like COUNTY, except Dublin, Cork, Galway and Limerick are broken up. 
- cso_name: a version of the name of the LEA which may be matched to CSO datasets
- Pop2016: The population of the LEA according to Census 2016 data.
- geometry: a list-column containing the geographic coordinates for each LEA.

You can have a look at ```lea_166``` using the ```glimpse()``` function:

```{r glimpse}
glimpse(lea_166)
```

## First plot

Let's take a quick look at the map that we now have using ggplot. ggplot is one of the packages within tidyverse which is very useful for making all kinds of nice plots).

```{r first_plot , message=FALSE , results="hide"}
ggplot() + geom_sf(data= lea_166)
```

This structure of using ```ggplot()``` followed by ```+ geom_XXX()``` will be familiar to users of ggplot (```XXX``` here might be ```line```, ```bar``` etc. depending on the type of plot). 

Note that the following piece of code is equivalent, and doesn't require ```data = ```:

```{r first_plot_alternative , eval=FALSE }
ggplot(lea_166) + geom_sf()
```

Even though this layout is probably more commonly used, I will be using the previous layout because later on I'll be using multiple ```geom_sf()``` functions to build up a plot in layers, and I find that the dataframe being used is less ambiguous that way. 

 


## Aggregating up for counties and NUTS regions

Maps for counties, admin areas, NUTS2 and NUTS3 regions can be produced using ```lea_166```. To produce a map of counties, for example, use the code below. The key function here is ```st_union()``` which can be used to join sf objects. 

```{r aggregating , message=FALSE , results="hide"}
county_map <- lea_166 %>% 
  group_by(COUNTY) %>% 
  summarise(geometry = st_union(geometry) , AREA=sum(AREA))
```

Note that ```county_map``` has only 3 columns, which are ```COUNTY```, ```geometry``` and ```AREA```. ```AREA``` is calculated for each county using the ```sum()``` function above. You could do something similar for ```Pop2016``` if you wished. All other columns are lost in the ```summarise()``` step.

Let's plot ```county_map``` to see what it looks like.

```{r county_plot , message=FALSE , results="hide"}
ggplot() + geom_sf(data=county_map)
```

Try making a similar plot of the NUTS3 regions.

##  Colouring in selected areas of the map

Let's start with the LEA map and let's say we want all of the LEAs in the Border to be coloured in green. We can make a new dataframe called ```border_leas``` using filter as follows:

```{r border_filter , message=FALSE , results="hide"}
border_leas <- lea_166 %>% 
  filter(NUTS3 == "Border")
```

Now we can plot that as an extra layer on top of our usual LEA map

```{r first_green_plot , message=FALSE , results="hide"}
ggplot() + 
  geom_sf(data = lea_166) +
  geom_sf(data = border_leas , fill="green")
```

Note that we could have done the filter step within the ```geom_sf()``` function if we wanted to, like so:

```{r first_green_plot_alt, eval=FALSE}
ggplot() + 
  geom_sf(data = lea_166) +
  geom_sf(data = lea_166 %>% filter(NUTS3 == "Border") , fill="green")
```

The filter function is very powerful, and we can include multiple clauses separated by commas. Let's say we want all LEAs in the Border and South-West NUTS 3 regions or in County Offaly, and excluding the LEA of Kenmare and any LEA that includes the string 'Cork City'. I know this seems like a silly collection but hopefully it will give you a guide to making your own complex subsets.

```{r selected_areas_1 , message=FALSE , results="hide"}
selected_areas <- lea_166 %>% 
  filter(NUTS3 %in% c("Border" ,"South-West") | COUNTY =="Offaly" , 
         LEA != "Kenmare", 
         ! str_detect(LEA , "Cork City")) 
```

Note the use of ```!``` above in front of the ```str_detect``` function, which negates or produces the opposite of the logical expression in front of it. You could have used ```&``` instead of the commas in the argument of ```filter``` above, but using logical AND as well as logical OR can be unambiguous, so you should use extra brackets if doing so. Anyway, let's plot ```selected_areas```. 

```{r second_green_plot , message=FALSE , results="hide"}
ggplot() + 
  geom_sf(data = lea_166) +
  geom_sf(data = selected_areas , fill="green")
```

## Adding more layers and using ```theme_void()```

Let's take the previous map and add dark outlines for the NUTS 3 regions. I'm going to set ```fill``` to ```NA``` which means it won't have any fill colour, then set the line colour to black using ```colour="black"```, and I'll set the line width to 1 using ```size=1```. 

Let's add another coloured layer, we'll make all of Dublin blue. The line of code for this will need to go before the NUTS 3 outline, otherwise it will partially obscure that outline. 

I'm also going to add ```theme_void()``` here. With ggplot there are lots of different themes you can add to change the appearance of your plot, but for maps the only one I really use is ```theme_void()```. It's effect is to remove the axes and give you a clear background.

```{r nuts_outline , message=FALSE , results="hide"}
nuts_outline <- lea_166 %>% 
  group_by(NUTS3) %>% 
  summarise(geometry = st_union(geometry))

ggplot() + 
  geom_sf(data = lea_166) +
  geom_sf(data = selected_areas , fill="green") +
  geom_sf(data = lea_166 %>% filter(COUNTY=="Dublin") , fill="blue") +
  geom_sf(data = nuts_outline , fill= NA , colour="black", size=1) +
  theme_void()
```