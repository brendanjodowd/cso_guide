---
title: "Statistical Disclosure Control using sdcTable"
author: "[Home](https://brendanjodowd.github.io)"
output: 
  html_document:
    css: style.css
    toc: true
    toc_float: true
    toc_collapsed: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## What this guide is about

This is a guide for implementing Statistical Disclosure Controls (SDC) on tabular data using R with the [sdcTable package](https://cran.r-project.org/web/packages/sdcTable/vignettes/sdcTable.html). It will include a range of different circumstances that I have encountered. 

This guide does not give a general overview on  SDC. The CSO have produced a very good document on [Best Practice for Statistical Disclosure Control of Tabular Data](https://www.cso.ie/en/media/csoie/aboutus-new/dataforresearchers/CSO_Guidance_on_Tabular_SDC.docx) (docx, 365KB).

Statistical Disclosure Controls are measures that protect against the publication of information relating to an individual person, company or organisation. Implementing robust SDC provides assurance to data providers that their data won't be inadvertently made public. As mentioned already, this guide covers cell suppression in tabular outputs, which is generally required where certain cross-tabulations are sparsely populated. 'Unsafe cells' are identified for *primary suppression*. Usually other cells need to be suppressed too, so that the value of an unsafe cell cannot be deduced using the aggregate totals and remaining data, and this is called *secondary suppression*. 

## Setup

As well as the [sdcTable package](https://cran.r-project.org/web/packages/sdcTable/vignettes/sdcTable.html) for R, we will be using the [tidyverse](https://tidyverse.tidyverse.org/) collection of packages throughout.

```{r packages , message=FALSE, warning=FALSE}
library(tidyverse)
library(sdcTable)
```

We will start with a dataset called `company_sales_1` which can be imported into R as a csv. This dataset contains sales information for 60 fictional companies located in Connaught. There are five columns, the ID and Name of each company, then the COunty in which it is located, a Y/N indicator to indicate if the company received some kind of aid, and the value of Sales for the year.

```{r import_1 , message=FALSE, warning=FALSE}
company_sales_1 <- read_csv("input/company_sales_1.csv")

head(company_sales_1)
```

## Simple run-through

Here we will produce aggregate sales data broken down across the two dimensions, County and Aid. We want aggregates for all Counties ("Connaught") and all companies including those that did and did not receive aid. 

The key steps are as follows:

1. Create hierarchies using `hier_create`
2. Create sdcProblem object using `makeProblem`
3. Primary suppression using `primarySuppression`
4. Secondary suppression using `protectTable`
5. Review outputs using `getInfo`

The objects created at steps 2, 3 and 4 have a class and structure which is specific to the package `sdcTable`. They may appear complex at first, but we will see how to get the necessary information out of them. 

Later sections will show more complex cases which will be presented as variations of this simple example. 

### 1. Defining hierachies

We need to define a hierarchy for each of our two dimensions `County` and `Aid` which we shall call `dimCounty` and `dimAid`. These are created using the `hier_create` function from the `sdcTable` package as shown below. The total category is identified as the 'root' of the hierarchy. Note that this total name/classification does not exist in the microdata. The underlying classifications are then created using the `nodes` argument to the function. There are other ways of creating hierarchies, either as a matrix or by creating them in a csv and importing that, which could be useful if you have a hierarchy with a large number of classifications. 

```{r hier_1 , message=FALSE, warning=FALSE}
dimCounty <- hier_create(root = "Connaught",
                         nodes = c("Galway",
                                   "Leitrim",
                                   "Mayo",
                                   "Roscommon",
                                   "Sligo"))

dimAid <- hier_create(root = "All companies",
                      nodes = c("Y",
                                "N"))
```
We can view our hierarchies using the function `hier_display`.

```{r display_1 , message=FALSE, warning=FALSE}
hier_display(dimCounty)

hier_display(dimAid)
```

### 2. Setting up the SDC problem

We use the function `makeProblem` to create an object of class `sdcProblem` as shown below. We are making use of three arguments: `data`, which is the dataset containing the microdata; `dimList`, which is a list object containing the hierarchies that we have created, each identified using a name which matches the name of the variable as it appears in the microdata; and `numVarInd`, the name of the variable containing the numerical data that we want to aggregate.

```{r prob_1 , message=FALSE, warning=FALSE}
sales_sdc_problem <- makeProblem(data = company_sales_1,
                           dimList = list(County = dimCounty, Aid = dimAid),
                           numVarInd = "Sales")
```
The object `sales_sdc_problem` has a specific class called 'sdcProblem'. It contains information about the microdata, the hierarchies, and protection parameters generated by the function `makeProblem`. To learn more about the contents of this object see the [documentation](https://www.rdocumentation.org/packages/sdcTable/versions/0.31/topics/sdcProblem-class). In the next step we will use it to carry out primary suppression.

### 3. Primary suppression

Primary suppression is carried out using the function `primarySuppression`. The first argument is the sdcProblem object (`sales_sdc_problem`, in our case), and the second argument is `type`. This can take one of four values: 

- `"freq"` for frequency rule with additional parameter `maxN` for the maximum number of entities in an unsafe cell (default value is 3) 
- `"nk"` for nk-dominance rule with additional parameters `n` and `k` (defaults of 2 and 85 respectively, meaning that in a safe cell two entities cannot contribute more than 85% of the aggregate value)
- `"p"` for p-percent rule with additional parameter `p` (default value of 80, meaning that in a safe cell, if the two largest contributors were removed then the remaining value has to be greater than 80% of the largest contributor)
- `"pq"` for the pq-rule with additional parameter `pq` which is a vector of length two. (The default value of pq is `c(25,50)`, meaning that in a safe cell, if the two largest contributors are removed then 50% of the remaining value should be greater than 25% of the largest contributor.)

For the `"nk"`, `"p"` and `"pq"` options there is one further mandatory argument to define the name of numerical variable which is `numVarName`. 

Here we'll use the nk-dominance rule with default parameters:

```{r prim_1 , message=FALSE, warning=FALSE}
sales_sdc_primary <- primarySuppression(sales_sdc_problem, 
                                        type = "nk", 
                                        numVarName = "Sales")
```

The output from this function, which we have called `sales_sdc_primary`, is of the same class 'sdcProblem' as the input object `sales_sdc_problem`. However the primary suppression rule has been implemented which we can see if we look at the slot called 'sdcStatus'. We can use the function `getInfo` to do this. This function is part of the sdcTable package, and it allows us to query the objects that are made through the suppression process. Here we see that in `sales_sdc_problem` there are 18 cells marked 's' for 'safe', but in `sales_sdc_primary` which has had primary suppression applied, there is one cell marked 'u' for 'unsafe'. 

```{r getInfo_1 , message=FALSE, warning=FALSE}
getInfo(sales_sdc_problem, type="sdcStatus")
getInfo(sales_sdc_primary, type="sdcStatus")
```

### 4. Secondary suppression

Secondary suppression is carried out using the function `protectTable` which has two main arguments. The first argument is the sdcProblem object to which primary suppression has already been applied (`sales_sdc_primary` in our case). The second main argument is `method` which allows us to choose an algorithm for secondary suppression. There are four options, and here I am copying the descriptions from the [Help page for this function](https://www.rdocumentation.org/packages/sdcTable/versions/0.32.2/topics/protectTable):

- "OPT": protect the complete problem at once using a cut and branch algorithm. The optimal algorithm should be used for small problem-instances only.
- "HITAS": split the overall problem in smaller problems. These problems are protected using a top-down approach.
- "HYPERCUBE": protect the complete problem by protecting sub-tables with a fast heuristic that is based on finding and suppressing geometric structures (n-dimensional cubes) that are required to protect primary sensitive table cells.
- "SIMPLEHEURISTIC" and "SIMPLEHEURISTIC_OLD": heuristic procedures which might be applied to large(r) problem instances.

There are some other arguments for parameters to these algorithms that can be varied but I have not used them. You can investigate them yourself on the [Help page for `protectTable`](https://www.rdocumentation.org/packages/sdcTable/versions/0.32.2/topics/protectTable). 


```{r sec_1 , message=FALSE, warning=FALSE}
sales_sdc_secondary <- protectTable(sales_sdc_primary, method = "HITAS")
```

The resulting object has both primary and secondary suppression applied. The next section shows how to view the results. 

### 5. Reviewing outputs

You can view the suppression results by extracting the `finalData` information from `sales_sdc_secondary` using the `getInfo` function. As you can see in the output printed below there is a new column called `sdcStatus`. It takes a value of `s` for safe cells, `u` for unsafe cells (as determined in the primary suppression), and `x` for cells that are deemed unsafe by the secondary suppression algorithm. We can see below that there is one 'unsafe' cell which relates to companies in Leitrim that received Aid. Since the total figure for Leitrim is also given (row 7 in the output shown) the secondary suppression of Leitrim companies that did not receive Aid is required. And since the total figure for all companies in Connaught that did and did not receive Aid is given (rows 2 and 3), suppression of one other county is also required. In this case the algorithm has chosen Sligo (rows 17 and 18).

```{r getInfo_final , message=FALSE, warning=FALSE}
sdc_output <- getInfo(sales_sdc_secondary , type = "finalData")

print(sdc_output)
```

The variable `sdcStatus` can also take a value `z`, and we will see later that this can come about when we override the secondary suppression to publish certain cross-tabulations.  
